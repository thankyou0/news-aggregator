/// <reference path="lcon-lexer.ts" />
/// <reference path="typings/underscore.d.ts" />
var lexer = require('./lcon-lexer');
var _ = require('underscore');

var SubState;
(function (SubState) {
    SubState[SubState["Key"] = 0] = "Key";
    SubState[SubState["Value"] = 1] = "Value";
    SubState[SubState["Comma"] = 2] = "Comma";
    SubState[SubState["AfterIndent"] = 3] = "AfterIndent";
})(SubState || (SubState = {}));

var BlockType;
(function (BlockType) {
    BlockType[BlockType["Array"] = 0] = "Array";
    BlockType[BlockType["Object"] = 1] = "Object";
    BlockType[BlockType["Scalar"] = 2] = "Scalar";
})(BlockType || (BlockType = {}));

function unexpected(token) {
    error("Unexpected " + lexer.TokenType[token.type], token);
}

function error(message, token) {
    throw message + " (at line " + token.start.line + ", column " + (token.start.column + 1) + ")";
}

function emptyToken(type) {
    return {
        type: type,
        value: "",
        start: { line: 0, column: 0 },
        end: { line: 0, column: 0 }
    };
}

function parseWithBuilder(src, builder) {
    var l = new lexer.Lexer();
    return exports.parseTokens(l.tokenize(src), builder);
}
exports.parseWithBuilder = parseWithBuilder;

function parseTokens(tokens, builder) {
    if (tokens.length === 0)
        return builder.initObject({ line: 0, column: 0 });
    else if (tokens.length === 1)
        switch (tokens[0].type) {
            case 2 /* Null */:
                return builder.processNull(tokens[0].start, tokens[0].end);
            case 0 /* True */:
                return builder.processBoolean(true, tokens[0].start, tokens[0].end);
            case 1 /* False */:
                return builder.processBoolean(false, tokens[0].start, tokens[0].end);
            case 3 /* Number */:
                return builder.processNumber(Number(tokens[0].value), tokens[0].start, tokens[0].end);
            case 4 /* String */:
                return builder.processString(tokens[0].value, tokens[0].start, tokens[0].end);
            default:
                unexpected(tokens[0]);
        }
    var states = [], output = builder.initArray({ line: 0, column: 0 }), chain = output, stack = [chain], subState = 3 /* AfterIndent */, lastKey = null, pos = -1, currentToken = null, nextToken = tokens[0], next;

    function appendValueToChain(value) {
        if (lastKey !== null || builder.isObject(chain))
            builder.appendValueToObject(value, chain);
        else
            builder.appendValueToArray(value, chain);
    }

    function keyState() {
        if (currentToken.type === 4 /* String */) {
            builder.appendKeyToObject(currentToken.value, chain, currentToken.start, currentToken.end);
            lastKey = currentToken.value;
            subState = 1 /* Value */;
        } else
            error("Expected key (String), got " + lexer.TokenType[currentToken.type] + " instead.", currentToken);
    }

    function valueState() {
        var paren = false;
        switch (currentToken.type) {
            case 2 /* Null */:
                appendValueToChain(builder.processNull(currentToken.start, currentToken.end));
                subState = 2 /* Comma */;
                break;
            case 0 /* True */:
                appendValueToChain(builder.processBoolean(true, currentToken.start, currentToken.end));
                subState = 2 /* Comma */;
                break;
            case 1 /* False */:
                appendValueToChain(builder.processBoolean(false, currentToken.start, currentToken.end));
                subState = 2 /* Comma */;
                break;
            case 3 /* Number */:
                appendValueToChain(builder.processNumber(Number(currentToken.value), currentToken.start, currentToken.end));
                subState = 2 /* Comma */;
                break;
            case 4 /* String */:
                switch (nextToken ? nextToken.type : 7 /* Newline */) {
                    case 6 /* Bullet */:
                    case 5 /* Comma */:
                    case 7 /* Newline */:
                    case 13 /* ClosingBrace */:
                    case 11 /* ClosingBracket */:
                    case 9 /* ClosingParen */:
                    case 15 /* Outdent */:
                        appendValueToChain(builder.processString(currentToken.value, currentToken.start, currentToken.end));
                        subState = 2 /* Comma */;
                        break;
                    default:
                        next = builder.initObject(currentToken.start);
                        builder.appendKeyToObject(currentToken.value, next, currentToken.start, currentToken.end);
                        appendValueToChain(next);
                        chain = next;
                        break;
                }
                break;
            case 14 /* Indent */:
                subState = 3 /* AfterIndent */;
                break;
            case 8 /* OpeningParen */:
                paren = true;
            case 12 /* OpeningBrace */:
                states.push({
                    closingToken: paren ? 9 /* ClosingParen */ : 13 /* ClosingBrace */,
                    block: 1 /* Object */
                });
                next = builder.initObject(currentToken.start);
                appendValueToChain(next);
                stack.push(next);
                chain = next;
                subState = 0 /* Key */;
                break;
            case 10 /* OpeningBracket */:
                states.push({ closingToken: 11 /* ClosingBracket */, block: 0 /* Array */ });
                next = builder.initArray(currentToken.start);
                appendValueToChain(next);
                stack.push(next);
                chain = next;
                subState = 1 /* Value */;
                break;
            default:
                unexpected(currentToken);
        }
    }

    function commaState() {
        switch (currentToken.type) {
            case 7 /* Newline */:
                if (lastKey !== null) {
                    error("Key '" + lastKey + "' is missing a value.", currentToken);
                }
                if (state && state.block === 0 /* Array */) {
                    var lastItem = builder.lastElementOfArray(_.last(stack));
                    if (builder.isObject(lastItem))
                        chain = lastItem;
                    else
                        unexpected(currentToken);
                } else
                    chain = _.last(stack);
                subState = 0 /* Key */;
                break;
            case 5 /* Comma */:
                chain = _.last(stack);
                subState = (state && state.block !== 1 /* Object */) ? 1 /* Value */ : 0 /* Key */;
                break;
            case 6 /* Bullet */:
                if (state && state.block === 0 /* Array */) {
                    chain = _.last(stack);
                    subState = 1 /* Value */;
                } else
                    error("Bullets (-) are not valid outside of an array", currentToken);
                break;
            default:
                unexpected(currentToken);
        }
    }

    function afterIndentState() {
        //console.log("AFTER INDENT: output=" + out)
        if (currentToken.type === 15 /* Outdent */) {
            error("Empty indented block.", currentToken);
        } else if (currentToken.type === 4 /* String */ && nextToken.type !== 15 /* Outdent */) {
            states.push({ closingToken: 15 /* Outdent */, block: 1 /* Object */ });
            next = builder.initObject(currentToken.start);
            appendValueToChain(next);
            stack.push(next);
            chain = next;
            subState = 0 /* Key */;
            keyState();
        } else if (currentToken.type === 6 /* Bullet */) {
            states.push({ closingToken: 15 /* Outdent */, block: 0 /* Array */ });
            next = builder.initArray(currentToken.start);
            appendValueToChain(next);
            stack.push(next);
            chain = next;
            subState = 1 /* Value */;
        } else {
            states.push({ closingToken: 15 /* Outdent */, block: 2 /* Scalar */ });
            subState = 1 /* Value */;
            valueState();
        }
    }

    while (++pos < tokens.length) {
        var state = states.length > 0 ? _.last(states) : null;
        currentToken = nextToken;
        nextToken = (pos < tokens.length - 1) ? tokens[pos + 1] : null;

        // Close an open object or array
        if (state && currentToken.type === state.closingToken) {
            switch (state.block) {
                case 1 /* Object */:
                    if (subState === 1 /* Value */) {
                        error("Key '" + lastKey + "' is missing a value.", currentToken);
                    }
                    builder.closeObject(stack.pop(), currentToken.end);
                    chain = _.last(stack);
                    break;
                case 0 /* Array */:
                    builder.closeArray(stack.pop(), currentToken.end);
                    chain = _.last(stack);
                    break;
                case 2 /* Scalar */:
            }
            subState = 2 /* Comma */;
            if (state != null)
                states.pop();
            continue;
        }

        // Parse individual tokens
        var lastSubState = subState;
        switch (subState) {
            case 0 /* Key */:
                keyState();
                break;
            case 1 /* Value */:
                valueState();
                break;
            case 2 /* Comma */:
                commaState();
                break;
            case 3 /* AfterIndent */:
                afterIndentState();
                break;
        }
        if (lastSubState !== 0 /* Key */)
            lastKey = null;
    }
    return builder.lastElementOfArray(output);
}
exports.parseTokens = parseTokens;
//# sourceMappingURL=lcon-parser.js.map
