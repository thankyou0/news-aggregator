var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="typings/underscore.d.ts" />
var parser = require("./lcon-parser");
var lexer = require("./lcon-lexer");
var orderedJson = require("./ordered-json");
var _ = require("underscore");

var TreeBuilderBase = (function () {
    function TreeBuilderBase() {
        this.lastElementOfArray = _.last;
    }
    TreeBuilderBase.prototype.closeObject = function (object, end) {
    };
    TreeBuilderBase.prototype.closeArray = function (array, end) {
    };

    TreeBuilderBase.prototype.processString = function (value, start, end) {
        return value;
    };
    TreeBuilderBase.prototype.processNumber = function (value, start, end) {
        return value;
    };
    TreeBuilderBase.prototype.processBoolean = function (value, start, end) {
        return value;
    };
    TreeBuilderBase.prototype.processNull = function (start, end) {
        return null;
    };
    return TreeBuilderBase;
})();

var JsonTreeBuilder = (function (_super) {
    __extends(JsonTreeBuilder, _super);
    function JsonTreeBuilder() {
        _super.apply(this, arguments);
        this.keyQueue = [];
    }
    JsonTreeBuilder.prototype.initObject = function (start) {
        return {};
    };
    JsonTreeBuilder.prototype.initArray = function (start) {
        return [];
    };
    JsonTreeBuilder.prototype.appendKeyToObject = function (key, object, start, end) {
        this.keyQueue.push(key);
    };
    JsonTreeBuilder.prototype.appendValueToArray = function (value, array) {
        array.push(value);
    };
    JsonTreeBuilder.prototype.appendValueToObject = function (value, object) {
        object[this.keyQueue.shift()] = value;
    };
    JsonTreeBuilder.prototype.isObject = function (thing) {
        return !_.isArray(thing) && !_.isString(thing) && _.isObject(thing);
    };
    return JsonTreeBuilder;
})(TreeBuilderBase);

var OrderedJsonTreeBuilder = (function (_super) {
    __extends(OrderedJsonTreeBuilder, _super);
    function OrderedJsonTreeBuilder() {
        _super.apply(this, arguments);
        this.keyQueue = [];
    }
    OrderedJsonTreeBuilder.prototype.initObject = function (start) {
        return [false];
    };
    OrderedJsonTreeBuilder.prototype.initArray = function (start) {
        return [true];
    };
    OrderedJsonTreeBuilder.prototype.appendKeyToObject = function (key, object, start, end) {
        object.push(key);
    };
    OrderedJsonTreeBuilder.prototype.appendValueToArray = function (value, array) {
        array.push(value);
    };
    OrderedJsonTreeBuilder.prototype.appendValueToObject = function (value, object) {
        object.push(value);
    };
    OrderedJsonTreeBuilder.prototype.isObject = function (thing) {
        return _.isArray(thing) && thing[0] === false;
    };
    return OrderedJsonTreeBuilder;
})(TreeBuilderBase);

exports.orderedToUnordered = orderedJson.orderedToUnordered;

exports.parseWithBuilder = parser.parseWithBuilder;

function parseOrdered(src) {
    return parser.parseWithBuilder(src, new OrderedJsonTreeBuilder());
}
exports.parseOrdered = parseOrdered;

function parseUnordered(src) {
    return parser.parseWithBuilder(src, new JsonTreeBuilder());
}
exports.parseUnordered = parseUnordered;

function isLegalWithoutQuotes(str) {
    if (str == "true" || str == "false" || str == "null" || str == "-")
        return false;
    var match = lexer.Lexer.UNQUOTED_STRING.exec(str);
    if (match && match[0].length === str.length) {
        match = lexer.Lexer.NUMBER.exec(str);
        return !match || match[0].length !== str.length;
    } else
        return false;
}

function stringifyUnordered(data) {
    // There's a lot of repetition here that could have been refactored out into
    // subroutines, but deeply-nested data could easily cause this recursive
    // function to overflow the stack. Adding subroutines would only make the
    // problem worse.
    var output, first = true, i;
    if (_.isArray(data)) {
        output = "[";
        for (i = 0; i < data.length; i++) {
            if (first)
                first = false;
            else
                output += ", ";
            output += exports.stringifyUnordered(data[i]);
        }
        return output + "]";
    } else if (_.isObject(data)) {
        var keys = _.keys(data);
        if (keys.length === 1) {
            return exports.stringifyUnordered(keys[0]) + " " + exports.stringifyUnordered(data[keys[0]]);
        } else {
            // I could have used _.foldl, but, once again, stack space...
            output = "(";
            for (i = 0; i < keys.length; i++) {
                if (first)
                    first = false;
                else
                    output += ", ";
                output += exports.stringifyUnordered(keys[i]) + " " + exports.stringifyUnordered(data[keys[i]]);
            }
            return output + ")";
        }
    } else if (_.isString(data)) {
        if (isLegalWithoutQuotes(data))
            return data;
        else
            return JSON.stringify(data);
    } else if (_.isNumber(data) || _.isBoolean(data) || _.isNull(data)) {
        return JSON.stringify(data);
    } else {
        throw new TypeError("Cannot stringify: object contains non-JSON data (such as functions).");
    }
}
exports.stringifyUnordered = stringifyUnordered;

function stringifyOrdered(data) {
    var output, first = true, i;
    if (_.isArray(data) && data.length > 0) {
        output = (data[0] ? "[" : "(");
        if (data[0])
            for (i = 1; i < data.length; i++) {
                if (first)
                    first = false;
                else
                    output += ", ";
                output += exports.stringifyOrdered(data[i]);
            }
        else if (data.length === 3) {
            return exports.stringifyOrdered(data[1]) + " " + exports.stringifyOrdered(data[2]);
        } else
            for (i = 1; i < data.length; i += 2) {
                if (first)
                    first = false;
                else
                    output += ", ";
                output += exports.stringifyOrdered(data[i]) + " " + exports.stringifyOrdered(data[i + 1]);
            }
        return output + (data[0] ? "]" : ")");
    } else if (_.isString(data)) {
        if (isLegalWithoutQuotes(data))
            return data;
        else
            return JSON.stringify(data);
    } else if (_.isNumber(data) || _.isBoolean(data) || _.isNull(data)) {
        return JSON.stringify(data);
    } else {
        throw new TypeError("Cannot stringify: object contains non-ordered-JSON data (such as objects or functions).");
    }
}
exports.stringifyOrdered = stringifyOrdered;

function stringifyOrderedJSON(data, indent, indentStep) {
    if (!indent)
        indent = 0;
    if (!indentStep)
        indentStep = indent;
    var output, first = true, i, j;
    if (_.isArray(data) && data.length > 0) {
        output = (data[0] ? "[" : "{") + (indent > 0 && data.length > 1 ? "\n" : "");
        if (data[0]) {
            for (i = 1; i < data.length; i++) {
                if (first)
                    first = false;
                else
                    output += (indent > 0 ? ",\n" : ",");
                for (j = 0; j < indent; j++)
                    output += " ";
                output += exports.stringifyOrderedJSON(data[i], indent + indentStep, indentStep);
            }
        } else {
            for (i = 1; i < data.length; i += 2) {
                if (first)
                    first = false;
                else
                    output += (indent > 0 ? ",\n" : ",");
                for (j = 0; j < indent; j++)
                    output += " ";
                output += JSON.stringify(data[i]) + ": " + exports.stringifyOrderedJSON(data[i + 1], indent + indentStep, indentStep);
            }
        }
        if (indent > 0 && data.length > 1) {
            output += "\n";
            for (j = 0; j < indent - indentStep; j++)
                output += " ";
        }
        return output + (data[0] ? "]" : "}");
    } else if (_.isString(data) || _.isNumber(data) || _.isBoolean(data) || _.isNull(data)) {
        return JSON.stringify(data);
    } else {
        throw new TypeError("Cannot stringify: object contains non-ordered-JSON data (such as objects or functions).");
    }
}
exports.stringifyOrderedJSON = stringifyOrderedJSON;
//# sourceMappingURL=lcon.js.map
